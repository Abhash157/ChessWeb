{"version":3,"file":"js/main.52d99e4578ad4fcb64ac.js","mappings":"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","sources":["webpack://chessweb/./script.js"],"sourcesContent":["// DOM Elements\nconst board = document.getElementById(\"chessboard\");\nconsole.log(\"Initial board DOM element:\", board); // Diagnostic 1\nconst debugBox = document.getElementById(\"debug\");\nconst gameStatus = document.getElementById(\"game-status\");\nconst moveList = document.getElementById(\"move-list\");\nconst whiteCaptured = document.getElementById(\"white-captured\");\nconst blackCaptured = document.getElementById(\"black-captured\");\nconst promotionModal = document.getElementById(\"promotion-modal\");\nconst whiteTimeDisplay = document.getElementById(\"white-time\");\nconst blackTimeDisplay = document.getElementById(\"black-time\");\nconst whiteClockElement = document.querySelector(\".white-clock\");\nconst blackClockElement = document.querySelector(\".black-clock\");\n\n// Game state constants\nconst PLAYER = {\n  WHITE: 0,\n  BLACK: 1\n};\n\n// Game mode constants\nconst GAME_MODE = {\n  LOCAL: 'local',   // Local 2-player\n  AI: 'ai',         // Playing against AI\n  ONLINE: 'online'  // Playing online against another player\n};\n\n// Current game mode\nlet currentGameMode = GAME_MODE.LOCAL;\n\n// Chess clock state\nconst CLOCK = {\n  initialTime: 600, // 10 minutes in seconds\n  whiteTime: 600,\n  blackTime: 600,\n  timerInterval: null,\n  isRunning: false,\n  activePlayer: PLAYER.WHITE, // Matches the initial turn value\n  lowTimeThreshold: 60, // 1 minute in seconds\n};\n\n// Game state variables\nlet selectedSquare = null;\nwindow.turn = PLAYER.WHITE; // Make turn globally accessible\nlet invalidOpacity = 0;\nlet pendingPromotion = null;\nlet squares = null; // Will be populated after board creation\n\n// Game state object\nconst gameState = {\n  whiteCanCastleKingside: true,\n  whiteCanCastleQueenside: true,\n  blackCanCastleKingside: true,\n  blackCanCastleQueenside: true,\n  enPassantTarget: null,\n  lastPawnDoubleMove: null,\n  moveHistory: [],\n  capturedPieces: {\n    white: [],\n    black: []\n  },\n  moveCount: 1,\n  gameOver: false,\n  check: false,\n  checkmate: false,\n  stalemate: false,\n  fiftyMoveRule: false,\n  insufficientMaterial: false,\n  threefoldRepetition: false,\n  castlingRightsSnapshot: null,\n};\n\n// Chess pieces Unicode symbols\nconst pieces = {\n  white: {\n    king: \"\\u2654\",\n    queen: \"\\u2655\",\n    rook: \"\\u2656\",\n    bishop: \"\\u2657\",\n    knight: \"\\u2658\",\n    pawn: \"\\u2659\",\n    checked: false,\n    checkSquare: 0,\n    kingRow: 7,\n    kingCol: 4,\n  },\n  black: {\n    king: \"\\u265A\",\n    queen: \"\\u265B\",\n    rook: \"\\u265C\",\n    bishop: \"\\u265D\",\n    knight: \"\\u265E\",\n    pawn: \"\\u265F\",\n    checked: false,\n    checkSquare: 0,\n    kingRow: 0,\n    kingCol: 4,\n  },\n};\n\nconst whitePieces = [\n  pieces.white.king,\n  pieces.white.queen,\n  pieces.white.rook,\n  pieces.white.bishop,\n  pieces.white.knight,\n  pieces.white.pawn,\n];\n\nconst blackPieces = [\n  pieces.black.king,\n  pieces.black.queen,\n  pieces.black.rook,\n  pieces.black.bishop,\n  pieces.black.knight,\n  pieces.black.pawn,\n];\n\n// ===========================\n// Chess Clock Functions\n// ===========================\n\n/**\n * Formats time in seconds to MM:SS format\n * @param {number} seconds - Time in seconds\n * @returns {string} Formatted time string (MM:SS)\n */\nfunction formatTime(seconds) {\n  const minutes = Math.floor(seconds / 60);\n  const secs = seconds % 60;\n  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n}\n\n/**\n * Updates the chess clock displays\n */\nfunction updateClockDisplay() {\n  whiteTimeDisplay.textContent = formatTime(CLOCK.whiteTime);\n  blackTimeDisplay.textContent = formatTime(CLOCK.blackTime);\n  \n  // Add visual indicators\n  whiteTimeDisplay.classList.toggle('low-time', CLOCK.whiteTime <= CLOCK.lowTimeThreshold);\n  blackTimeDisplay.classList.toggle('low-time', CLOCK.blackTime <= CLOCK.lowTimeThreshold);\n  \n  // Highlight active clock\n  whiteClockElement.classList.toggle('active-clock', CLOCK.activePlayer === PLAYER.WHITE);\n  blackClockElement.classList.toggle('active-clock', CLOCK.activePlayer === PLAYER.BLACK);\n}\n\n/**\n * Starts the chess clock\n */\nfunction startClock() {\n  if (CLOCK.isRunning) return;\n  \n  CLOCK.timerInterval = setInterval(() => {\n    if (CLOCK.activePlayer === PLAYER.WHITE) {\n      CLOCK.whiteTime--;\n      if (CLOCK.whiteTime <= 0) {\n        handleTimeOut(PLAYER.WHITE);\n      }\n    } else {\n      CLOCK.blackTime--;\n      if (CLOCK.blackTime <= 0) {\n        handleTimeOut(PLAYER.BLACK);\n      }\n    }\n    updateClockDisplay();\n  }, 1000);\n  \n  CLOCK.isRunning = true;\n}\n\n/**\n * Stops the chess clock\n */\nfunction stopClock() {\n  if (CLOCK.timerInterval) {\n    clearInterval(CLOCK.timerInterval);\n    CLOCK.timerInterval = null;\n    CLOCK.isRunning = false;\n  }\n}\n\n/**\n * Switches the active player on the clock\n */\nfunction switchClock() {\n  CLOCK.activePlayer = CLOCK.activePlayer === PLAYER.WHITE ? PLAYER.BLACK : PLAYER.WHITE;\n  updateClockDisplay();\n}\n\n/**\n * Handles the case when a player runs out of time\n * @param {number} player - The player who ran out of time (PLAYER.WHITE or PLAYER.BLACK)\n */\nfunction handleTimeOut(player) {\n  stopClock();\n  gameState.gameOver = true;\n  \n  const winner = player === PLAYER.WHITE ? \"Black\" : \"White\";\n  gameStatus.textContent = `Time's up! ${winner} wins by timeout!`;\n  checkForEndOfGame(); // Update game state display for timeout\n}\n\n/**\n * Resets the chess clock to initial state\n */\nfunction resetClock() {\n  stopClock();\n  CLOCK.whiteTime = CLOCK.initialTime;\n  CLOCK.blackTime = CLOCK.initialTime;\n  CLOCK.activePlayer = PLAYER.WHITE;\n  updateClockDisplay();\n}\n\n// ===========================\n// Board Setup Functions\n// ===========================\n\n/**\n * Creates the chessboard grid with event listeners\n */\nfunction createChessboard() {\n  console.log(\"createChessboard called. board DOM element:\", board); // Diagnostic 2\n  if (!board) {\n    console.error(\"Chessboard DOM element 'chessboard' not found in createChessboard. Cannot create board.\");\n    return;\n  }\n  board.innerHTML = ''; \n  let DIsquareCount = 0; // Diagnostic\n  for (let row = 0; row < 8; row++) {\n    for (let col = 0; col < 8; col++) {\n      const square = document.createElement(\"div\");\n      square.classList.add(\"square\");\n      square.classList.add((row + col) % 2 === 0 ? \"white\" : \"black\");\n      square.dataset.row = row;\n      square.dataset.col = col;\n      square.addEventListener(\"click\", () => squareClick(square));\n      board.appendChild(square);\n      DIsquareCount++; // Diagnostic\n    }\n  }\n  console.log(\"Number of squares created and appended in createChessboard:\", DIsquareCount); // Diagnostic 3\n  squares = document.querySelectorAll('.square'); \n  console.log(\"Number of .square elements found by querySelectorAll after createChessboard:\", squares.length); // Diagnostic 4\n}\n\n/**\n * Places the initial pieces on the board\n */\nfunction placePieces() {\n  const initialSetup = [\n    [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"],\n    Array(8).fill(\"pawn\"),\n    ...Array(4).fill(Array(8).fill(null)), // Empty rows\n    Array(8).fill(\"pawn\"),\n    [\"rook\", \"knight\", \"bishop\", \"queen\", \"king\", \"bishop\", \"knight\", \"rook\"],\n  ];\n\n  if (!squares) {\n    console.warn(\"placePieces: squares global variable is not set. Querying again.\");\n    squares = document.querySelectorAll('.square');\n  }\n  console.log(\"placePieces: Number of squares found:\", squares ? squares.length : 0); // Diagnostic 5\n\n  if (!squares || squares.length === 0) {\n    console.error(\"placePieces: No squares found to place pieces on. Has createChessboard run successfully?\");\n    return;\n  }\n  \n  squares.forEach((sq, index) => sq.textContent = ''); // Clear board first\n\n  initialSetup.forEach((row, rowIndex) => {\n    row.forEach((pieceType, colIndex) => {\n      if (pieceType) {\n        const square = squares[rowIndex * 8 + colIndex];\n        const color = rowIndex < 4 ? \"black\" : \"white\"; // Black pieces on rows 0-1, White on 6-7\n        square.textContent = pieces[color][pieceType];\n      }\n    });\n  });\n  // Reset king positions logically\n  pieces.white.kingRow = 7; pieces.white.kingCol = 4;\n  pieces.black.kingRow = 0; pieces.black.kingCol = 4;\n  // Reset castling rights for new game\n  gameState.whiteCanCastleKingside = true;\n  gameState.whiteCanCastleQueenside = true;\n  gameState.blackCanCastleKingside = true;\n  gameState.blackCanCastleQueenside = true;\n  gameState.enPassantTarget = null;\n}\n\n// ===========================\n// UI Update Functions (Continued)\n// ===========================\n/**\n * Updates the captured pieces display\n */\nfunction updateCapturedPieces() {\n  whiteCaptured.innerHTML = '';\n  blackCaptured.innerHTML = '';\n  \n  gameState.capturedPieces.white.forEach(piece => {\n    const pieceElement = document.createElement('span');\n    pieceElement.textContent = piece;\n    whiteCaptured.appendChild(pieceElement);\n  });\n  \n  gameState.capturedPieces.black.forEach(piece => {\n    const pieceElement = document.createElement('span');\n    pieceElement.textContent = piece;\n    blackCaptured.appendChild(pieceElement);\n  });\n}\n\n/**\n * Updates the move history display using algebraic notation\n */\nfunction updateMoveHistory() {\n  moveList.innerHTML = '';\n  \n  for (let i = 0; i < gameState.moveHistory.length; i += 2) {\n    const moveNumber = Math.floor(i / 2) + 1;\n    const whiteMove = gameState.moveHistory[i];\n    const blackMove = gameState.moveHistory[i + 1];\n    \n    const moveItem = document.createElement('div');\n    moveItem.classList.add('move-item');\n    \n    const moveNumberElement = document.createElement('div');\n    moveNumberElement.classList.add('move-number');\n    moveNumberElement.textContent = `${moveNumber}.`;\n    \n    const moveTextElement = document.createElement('div');\n    moveTextElement.classList.add('move-text');\n    \n    let moveText = `${algebraicNotation(whiteMove)}`;\n    if (blackMove) {\n      moveText += ` ${algebraicNotation(blackMove)}`;\n    }\n    \n    moveTextElement.textContent = moveText;\n    \n    moveItem.appendChild(moveNumberElement);\n    moveItem.appendChild(moveTextElement);\n    moveList.appendChild(moveItem);\n  }\n  \n  // Auto-scroll to bottom\n  moveList.scrollTop = moveList.scrollHeight;\n}\n\n/**\n * Converts a move to algebraic notation\n * @param {Object} move - The move object from gameState.moveHistory\n * @returns {string} The move in algebraic notation\n */\nfunction algebraicNotation(move) {\n  if (!move) return '';\n  \n  const files = 'abcdefgh';\n  const ranks = '87654321'; // Rank 8 is at index 0\n  \n  const fromFile = files[move.from.col];\n  const fromRank = ranks[move.from.row];\n  const toFile = files[move.to.col];\n  const toRank = ranks[move.to.row];\n  \n  let piece = '';\n  const pieceSymbol = move.pieceMovedOriginal; // The symbol of the piece that moved\n\n  if (pieceSymbol === pieces.white.king || pieceSymbol === pieces.black.king) piece = 'K';\n  else if (pieceSymbol === pieces.white.queen || pieceSymbol === pieces.black.queen) piece = 'Q';\n  else if (pieceSymbol === pieces.white.rook || pieceSymbol === pieces.black.rook) piece = 'R';\n  else if (pieceSymbol === pieces.white.bishop || pieceSymbol === pieces.black.bishop) piece = 'B';\n  else if (pieceSymbol === pieces.white.knight || pieceSymbol === pieces.black.knight) piece = 'N';\n  // Pawns do not get a letter prefix unless capturing\n\n  if (move.wasCastling) {\n    return move.castlingDetails.side === 'kingside' ? 'O-O' : 'O-O-O';\n  }\n  \n  const captureSymbol = (move.capturedPieceDirectly || move.wasEnPassantCapture) ? 'x' : '';\n  \n  let promotionSuffix = '';\n  if (move.wasPromotion && move.promotedToPieceType) {\n    let promotedPieceSymbol = '';\n    switch (move.promotedToPieceType) {\n      case 'queen': promotedPieceSymbol = 'Q'; break;\n      case 'rook': promotedPieceSymbol = 'R'; break;\n      case 'bishop': promotedPieceSymbol = 'B'; break;\n      case 'knight': promotedPieceSymbol = 'N'; break;\n    }\n    promotionSuffix = `=${promotedPieceSymbol}`;\n  }\n  \n  let checkSuffix = '';\n  if (move.resultedInCheckmate) checkSuffix = '#';\n  else if (move.resultedInCheck) checkSuffix = '+';\n\n  // Disambiguation (simplified: not fully implemented for all complex cases)\n  let disambiguation = ''; \n\n  if (piece === '') { // Pawn move\n    return captureSymbol ? `${fromFile}x${toFile}${toRank}${promotionSuffix}${checkSuffix}` : `${toFile}${toRank}${promotionSuffix}${checkSuffix}`;\n    } else {\n    return `${piece}${disambiguation}${captureSymbol}${toFile}${toRank}${checkSuffix}`;\n  }\n}\n\n// ===========================\n// Piece Animation\n// ===========================\n/**\n * Creates a piece element that can be animated\n * @param {string} pieceText - The Unicode character for the piece\n * @param {HTMLElement} square - The square element to place the piece in\n * @returns {HTMLElement} The created piece element\n */\nfunction createPieceElement(pieceText, square) {\n  const piece = document.createElement('div');\n  piece.className = 'piece-animation-clone'; // Use a distinct class\n  piece.textContent = pieceText;\n  // Style it to overlay correctly\n  const rect = square.getBoundingClientRect();\n  piece.style.position = 'fixed'; // Use fixed for viewport-relative positioning\n  piece.style.left = `${rect.left}px`;\n  piece.style.top = `${rect.top}px`;\n  piece.style.width = `${rect.width}px`;\n  piece.style.height = `${rect.height}px`;\n  piece.style.display = 'flex';\n  piece.style.alignItems = 'center';\n  piece.style.justifyContent = 'center';\n  // Attempt to match original square's font size, or use a default\n  const cs = window.getComputedStyle(square);\n  piece.style.fontSize = cs.fontSize || '2em'; \n  piece.style.zIndex = '1001'; // Ensure it's above other elements\n  piece.style.pointerEvents = 'none'; // Prevent interaction with the clone\n  document.body.appendChild(piece);\n  return piece;\n}\n\n/**\n * Animates a piece's movement from one square to another\n * @param {HTMLElement} fromSquare - Starting square\n * @param {HTMLElement} toSquare - Destination square\n * @param {string} pieceText - The piece being moved\n * @returns {Promise} Resolves when animation is complete\n */\nasync function animatePieceMovement(fromSquare, toSquare, pieceText) {\n  return new Promise(resolve => {\n    if (!fromSquare || !toSquare || !pieceText) {\n        console.warn(\"Animation skipped due to missing parameters\", fromSquare, toSquare, pieceText);\n        resolve();\n        return;\n    }\n    const pieceClone = createPieceElement(pieceText, fromSquare);\n    fromSquare.textContent = ''; // Visually clear original square earlier for smoother effect\n\n    const toRect = toSquare.getBoundingClientRect();\n    const currentRect = pieceClone.getBoundingClientRect(); // Get current position of the clone\n\n    // Calculate the movement distance based on fixed positions\n    const deltaX = toRect.left - currentRect.left;\n    const deltaY = toRect.top - currentRect.top;\n    \n    pieceClone.style.transition = 'transform 0.3s ease-out';\n    \n    requestAnimationFrame(() => {\n      pieceClone.style.transform = `translate(${deltaX}px, ${deltaY}px)`;\n    });\n\n    pieceClone.addEventListener('transitionend', () => {\n      pieceClone.remove();\n      // The actual placement on toSquare happens in the move logic after animation\n      resolve();\n    }, { once: true });\n  });\n}\n\n// ===========================\n// Move Validation and Helpers\n// ===========================\n\n/**\n * Highlights an invalid move temporarily\n * @param {HTMLElement} square - The square to highlight\n */\nfunction highlightInvalidMove(square) {\n  if (!square) return;\n  square.classList.add(\"invalidSquare\");\n  setTimeout(() => {\n    square.classList.remove(\"invalidSquare\");\n  }, 150);\n}\n\n/**\n * Checks if a square is under attack by opponent pieces\n * @param {number} row - The row to check\n * @param {number} col - The column to check\n * @param {number} colorOfDefender - PLAYER.WHITE or PLAYER.BLACK (the color of the piece potentially being attacked on that square)\n * @returns {boolean} True if the square is under attack\n */\nfunction isSquareUnderAttack(row, col, colorOfDefender) {\n  const attackerColor = colorOfDefender === PLAYER.WHITE ? PLAYER.BLACK : PLAYER.WHITE;\n  const attackerPieceSet = attackerColor === PLAYER.WHITE ? pieces.white : pieces.black;\n  // const attackerSymbols = attackerColor === PLAYER.WHITE ? whitePieces : blackPieces; // Not directly used, using attackerPieceSet.pieceName\n\n  // Check for pawn attacks\n  // Pawn attacks depend on the attacker's color, so the direction is relative to the attacker\n  const pawnAttackDirection = attackerColor === PLAYER.WHITE ? 1 : -1; \n  if (row - pawnAttackDirection >= 0 && row - pawnAttackDirection < 8) { // Check squares pawn could attack FROM\n    if (col > 0 && squares[(row - pawnAttackDirection) * 8 + (col - 1)].textContent === attackerPieceSet.pawn) return true;\n    if (col < 7 && squares[(row - pawnAttackDirection) * 8 + (col + 1)].textContent === attackerPieceSet.pawn) return true;\n  }\n\n  // Check for knight attacks\n  const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      if (squares[newRow * 8 + newCol].textContent === attackerPieceSet.knight) return true;\n    }\n  }\n\n  // Check for king attacks (for proximity, not for \"check\" itself, used for castling through check)\n  const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n  for (const [rowOffset, colOffset] of kingMoves) {\n    const newRow = row + rowOffset;\n    const newCol = col + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      if (squares[newRow * 8 + newCol].textContent === attackerPieceSet.king) return true;\n    }\n  }\n\n  // Check for rook/queen attacks (horizontal and vertical)\n  const straightDirections = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n  for (const [rowDir, colDir] of straightDirections) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const pieceOnSquare = squares[newRow * 8 + newCol].textContent;\n      if (pieceOnSquare !== \"\") {\n        if (pieceOnSquare === attackerPieceSet.rook || pieceOnSquare === attackerPieceSet.queen) return true;\n        break;\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n\n  // Check for bishop/queen attacks (diagonals)\n  const diagonalDirections = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n  for (const [rowDir, colDir] of diagonalDirections) {\n    let newRow = row + rowDir;\n    let newCol = col + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const pieceOnSquare = squares[newRow * 8 + newCol].textContent;\n      if (pieceOnSquare !== \"\") {\n        if (pieceOnSquare === attackerPieceSet.bishop || pieceOnSquare === attackerPieceSet.queen) return true;\n        break;\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return false;\n}\n\n/**\n * Checks if the king of the specified color is currently in check.\n * @param {number} kingColor - PLAYER.WHITE or PLAYER.BLACK.\n * @returns {boolean} True if the king is in check, false otherwise.\n */\nfunction isKingInCheck(kingColor) {\n  const kingData = kingColor === PLAYER.WHITE ? pieces.white : pieces.black;\n  if(kingData.kingRow === undefined || kingData.kingCol === undefined) {\n      console.error(\"King position undefined for color:\", kingColor, kingData);\n      // Try to find the king if its position is not tracked - this is a fallback\n      for(let r=0; r<8; r++){\n          for(let c=0; c<8; c++){\n              if(squares[r*8+c].textContent === kingData.king){\n                  kingData.kingRow = r;\n                  kingData.kingCol = c;\n                  console.warn(\"King position dynamically found. Ensure it is updated correctly.\");\n                  break;\n              }\n          }\n          if(kingData.kingRow !== undefined) break;\n      }\n      if(kingData.kingRow === undefined) return true; // Assume check if king not found\n  }\n  return isSquareUnderAttack(kingData.kingRow, kingData.kingCol, kingColor);\n}\n\n// ===========================\n// Move Generation and Legality\n// ===========================\n\nfunction getPseudoLegalMovesForPawn(square, sqRow, sqCol, pieceColor) {\n  const moves = [];\n  // const ownPieceSet = pieceColor === PLAYER.WHITE ? pieces.white : pieces.black; // Not needed directly\n  const opponentPieces = pieceColor === PLAYER.WHITE ? blackPieces : whitePieces;\n  const direction = pieceColor === PLAYER.WHITE ? -1 : 1;\n  const startRow = pieceColor === PLAYER.WHITE ? 6 : 1;\n\n  // Forward one square\n  if (sqRow + direction >= 0 && sqRow + direction < 8 && squares[(sqRow + direction) * 8 + sqCol].textContent === \"\") {\n    moves.push(squares[(sqRow + direction) * 8 + sqCol]);\n    // Forward two squares (from starting position)\n    if (sqRow === startRow && squares[(sqRow + 2 * direction) * 8 + sqCol].textContent === \"\") {\n      moves.push(squares[(sqRow + 2 * direction) * 8 + sqCol]);\n    }\n  }\n  // Diagonal captures\n  for (let colOffset of [-1, 1]) {\n    const newCol = sqCol + colOffset;\n    if (newCol >= 0 && newCol < 8 && sqRow + direction >= 0 && sqRow + direction < 8) {\n      const targetSquare = squares[(sqRow + direction) * 8 + newCol];\n      if (targetSquare && opponentPieces.includes(targetSquare.textContent)) {\n        moves.push(targetSquare);\n      }\n      // En passant\n      if (gameState.enPassantTarget &&\n          (sqRow + direction) === gameState.enPassantTarget.row &&\n          newCol === gameState.enPassantTarget.col &&\n          targetSquare.textContent === \"\") { // Target square must be empty for en-passant visualization\n        moves.push(targetSquare);\n      }\n    }\n  }\n  return moves;\n}\n\nfunction getPseudoLegalMovesForRook(square, sqRow, sqCol, pieceColor) {\n  const moves = [];\n  const opponentPieces = pieceColor === PLAYER.WHITE ? blackPieces : whitePieces;\n  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\n  for (const [rowDir, colDir] of directions) {\n    let newRow = sqRow + rowDir;\n    let newCol = sqCol + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const targetSquare = squares[newRow * 8 + newCol];\n      if (targetSquare.textContent === \"\") {\n        moves.push(targetSquare);\n      } else if (opponentPieces.includes(targetSquare.textContent)) {\n        moves.push(targetSquare);\n        break;\n      } else { // Own piece\n        break;\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return moves;\n}\n\nfunction getPseudoLegalMovesForKnight(square, sqRow, sqCol, pieceColor) {\n  const moves = [];\n  const ownPieces = pieceColor === PLAYER.WHITE ? whitePieces : blackPieces;\n  const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];\n\n  for (const [rowOffset, colOffset] of knightMoves) {\n    const newRow = sqRow + rowOffset;\n    const newCol = sqCol + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const targetSquare = squares[newRow * 8 + newCol];\n      if (!ownPieces.includes(targetSquare.textContent)) { // Can move to empty or opponent's square\n        moves.push(targetSquare);\n      }\n    }\n  }\n  return moves;\n}\n\nfunction getPseudoLegalMovesForBishop(square, sqRow, sqCol, pieceColor) {\n  const moves = [];\n  const opponentPieces = pieceColor === PLAYER.WHITE ? blackPieces : whitePieces;\n  const diagonals = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n\n  for (const [rowDir, colDir] of diagonals) {\n    let newRow = sqRow + rowDir;\n    let newCol = sqCol + colDir;\n    while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const targetSquare = squares[newRow * 8 + newCol];\n      if (targetSquare.textContent === \"\") {\n        moves.push(targetSquare);\n      } else if (opponentPieces.includes(targetSquare.textContent)) {\n        moves.push(targetSquare);\n        break;\n      } else { // Own piece\n        break;\n      }\n      newRow += rowDir;\n      newCol += colDir;\n    }\n  }\n  return moves;\n}\n\nfunction getPseudoLegalMovesForQueen(square, sqRow, sqCol, pieceColor) {\n  return [\n    ...getPseudoLegalMovesForRook(square, sqRow, sqCol, pieceColor),\n    ...getPseudoLegalMovesForBishop(square, sqRow, sqCol, pieceColor)\n  ];\n}\n\nfunction getPseudoLegalMovesForKing(square, sqRow, sqCol, pieceColor) {\n  const moves = [];\n  const ownPieces = pieceColor === PLAYER.WHITE ? whitePieces : blackPieces;\n  const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n  for (const [rowOffset, colOffset] of kingMoves) {\n    const newRow = sqRow + rowOffset;\n    const newCol = sqCol + colOffset;\n    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {\n      const targetSquare = squares[newRow * 8 + newCol];\n      if (!ownPieces.includes(targetSquare.textContent)) {\n        moves.push(targetSquare);\n      }\n    }\n  }\n  // Castling moves (pseudo-legal, legality check including 'not through check' is in isMoveLegal)\n  const kingInitialRow = pieceColor === PLAYER.WHITE ? 7 : 0;\n  const canCastleKingside = pieceColor === PLAYER.WHITE ? gameState.whiteCanCastleKingside : gameState.blackCanCastleKingside;\n  const canCastleQueenside = pieceColor === PLAYER.WHITE ? gameState.whiteCanCastleQueenside : gameState.blackCanCastleQueenside;\n  const rookPiece = pieceColor === PLAYER.WHITE ? pieces.white.rook : pieces.black.rook;\n\n  if (sqRow === kingInitialRow && sqCol === 4) { // King is on its starting square\n    if (canCastleKingside &&\n        squares[kingInitialRow * 8 + 5].textContent === \"\" &&\n        squares[kingInitialRow * 8 + 6].textContent === \"\" &&\n        squares[kingInitialRow * 8 + 7].textContent === rookPiece) {\n      moves.push(squares[kingInitialRow * 8 + 6]); // Target square for king\n    }\n    if (canCastleQueenside &&\n        squares[kingInitialRow * 8 + 3].textContent === \"\" &&\n        squares[kingInitialRow * 8 + 2].textContent === \"\" &&\n        squares[kingInitialRow * 8 + 1].textContent === \"\" && // Note: B file also empty for queen-side\n        squares[kingInitialRow * 8 + 0].textContent === rookPiece) {\n      moves.push(squares[kingInitialRow * 8 + 2]); // Target square for king\n    }\n  }\n  return moves;\n}\n\nfunction getPseudoLegalMovesForPiece(squareElement, pieceColor) {\n  const pieceText = squareElement.textContent;\n  const sqRow = parseInt(squareElement.dataset.row);\n  const sqCol = parseInt(squareElement.dataset.col);\n\n  if (pieceColor === PLAYER.WHITE) {\n    if (pieceText === pieces.white.pawn) return getPseudoLegalMovesForPawn(squareElement, sqRow, sqCol, PLAYER.WHITE);\n    if (pieceText === pieces.white.rook) return getPseudoLegalMovesForRook(squareElement, sqRow, sqCol, PLAYER.WHITE);\n    if (pieceText === pieces.white.knight) return getPseudoLegalMovesForKnight(squareElement, sqRow, sqCol, PLAYER.WHITE);\n    if (pieceText === pieces.white.bishop) return getPseudoLegalMovesForBishop(squareElement, sqRow, sqCol, PLAYER.WHITE);\n    if (pieceText === pieces.white.queen) return getPseudoLegalMovesForQueen(squareElement, sqRow, sqCol, PLAYER.WHITE);\n    if (pieceText === pieces.white.king) return getPseudoLegalMovesForKing(squareElement, sqRow, sqCol, PLAYER.WHITE);\n  } else { // PLAYER.BLACK\n    if (pieceText === pieces.black.pawn) return getPseudoLegalMovesForPawn(squareElement, sqRow, sqCol, PLAYER.BLACK);\n    if (pieceText === pieces.black.rook) return getPseudoLegalMovesForRook(squareElement, sqRow, sqCol, PLAYER.BLACK);\n    if (pieceText === pieces.black.knight) return getPseudoLegalMovesForKnight(squareElement, sqRow, sqCol, PLAYER.BLACK);\n    if (pieceText === pieces.black.bishop) return getPseudoLegalMovesForBishop(squareElement, sqRow, sqCol, PLAYER.BLACK);\n    if (pieceText === pieces.black.queen) return getPseudoLegalMovesForQueen(squareElement, sqRow, sqCol, PLAYER.BLACK);\n    if (pieceText === pieces.black.king) return getPseudoLegalMovesForKing(squareElement, sqRow, sqCol, PLAYER.BLACK);\n  }\n  return [];\n}\n\n/**\n * Checks if a move is legal (i.e., does not leave the player's king in check).\n * @param {HTMLElement} fromSquareElement - The square the piece is moving from.\n * @param {HTMLElement} toSquareElement - The square the piece is moving to.\n * @param {number} playerColor - PLAYER.WHITE or PLAYER.BLACK.\n * @returns {boolean} True if the move is legal, false otherwise.\n */\nfunction isMoveLegal(fromSquareElement, toSquareElement, playerColor) {\n  if (!fromSquareElement || !toSquareElement) return false; // Basic check\n  const movingPieceText = fromSquareElement.textContent;\n  const capturedPieceText = toSquareElement.textContent; // Content of target square before move\n  const fromRow = parseInt(fromSquareElement.dataset.row);\n  const fromCol = parseInt(fromSquareElement.dataset.col);\n  const toRow = parseInt(toSquareElement.dataset.row);\n  const toCol = parseInt(toSquareElement.dataset.col);\n\n  // Store original king position for restoration\n  const kingData = playerColor === PLAYER.WHITE ? pieces.white : pieces.black;\n  const originalKingRow = kingData.kingRow;\n  const originalKingCol = kingData.kingCol;\n\n  let enPassantVictimSquare = null;\n  let originalEnPassantVictimPiece = null;\n  let isCastlingMove = false;\n  let castlingRookFromSquare = null, castlingRookToSquare = null, originalRookTargetSquarePiece = null;\n\n  // --- Preliminary Castling Checks (Path, Rights, Not in Check) ---\n  if (movingPieceText === kingData.king && Math.abs(fromCol - toCol) === 2) { // Potential castling\n      isCastlingMove = true;\n      const kingInitialRow = playerColor === PLAYER.WHITE ? 7 : 0;\n      const rookPiece = playerColor === PLAYER.WHITE ? pieces.white.rook : pieces.black.rook;\n      \n      if (isKingInCheck(playerColor)) return false; // Cannot castle out of check\n\n      if (toCol === 6) { // Kingside\n          if (!( (playerColor === PLAYER.WHITE ? gameState.whiteCanCastleKingside : gameState.blackCanCastleKingside) &&\n                 squares[kingInitialRow * 8 + 5].textContent === \"\" &&\n                 squares[kingInitialRow * 8 + 6].textContent === \"\" && // King's landing square\n                 squares[kingInitialRow * 8 + 7].textContent === rookPiece &&\n                 !isSquareUnderAttack(kingInitialRow, 5, playerColor) && // Square king passes over (F1/F8)\n                 !isSquareUnderAttack(kingInitialRow, 6, playerColor)    // King's landing square (G1/G8)\n             )) return false;\n          castlingRookFromSquare = squares[kingInitialRow * 8 + 7];\n          castlingRookToSquare = squares[kingInitialRow * 8 + 5];\n      } else { // Queenside (toCol === 2)\n          if (!( (playerColor === PLAYER.WHITE ? gameState.whiteCanCastleQueenside : gameState.blackCanCastleQueenside) &&\n                 squares[kingInitialRow * 8 + 1].textContent === \"\" && // B1/B8\n                 squares[kingInitialRow * 8 + 2].textContent === \"\" && // C1/C8 (King's landing)\n                 squares[kingInitialRow * 8 + 3].textContent === \"\" && // D1/D8\n                 squares[kingInitialRow * 8 + 0].textContent === rookPiece &&\n                 !isSquareUnderAttack(kingInitialRow, 3, playerColor) && // Square king passes over (D1/D8)\n                 !isSquareUnderAttack(kingInitialRow, 2, playerColor)    // King's landing square (C1/C8)\n             )) return false;\n          castlingRookFromSquare = squares[kingInitialRow * 8 + 0];\n          castlingRookToSquare = squares[kingInitialRow * 8 + 3];\n      }\n      if (castlingRookToSquare) originalRookTargetSquarePiece = castlingRookToSquare.textContent; // Should be empty\n  }\n\n\n  // --- Simulate the move ---\n  toSquareElement.textContent = movingPieceText;\n  fromSquareElement.textContent = \"\";\n\n  if (movingPieceText === kingData.king) {\n    kingData.kingRow = toRow;\n    kingData.kingCol = toCol;\n  }\n  if (isCastlingMove && castlingRookFromSquare && castlingRookToSquare) {\n    castlingRookToSquare.textContent = castlingRookFromSquare.textContent;\n    castlingRookFromSquare.textContent = \"\";\n  }\n  // En passant simulation\n  const pawnBeingMoved = playerColor === PLAYER.WHITE ? pieces.white.pawn : pieces.black.pawn;\n  if (movingPieceText === pawnBeingMoved &&\n      gameState.enPassantTarget &&\n      toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col &&\n      capturedPieceText === \"\") { // Target square for en-passant move itself is empty\n    const victimPawnRow = playerColor === PLAYER.WHITE ? toRow + 1 : toRow - 1;\n    enPassantVictimSquare = squares[victimPawnRow * 8 + toCol];\n    if (enPassantVictimSquare) {\n        originalEnPassantVictimPiece = enPassantVictimSquare.textContent;\n        // Ensure the victim is actually an opponent's pawn\n        const opponentPawn = playerColor === PLAYER.WHITE ? pieces.black.pawn : pieces.white.pawn;\n        if (originalEnPassantVictimPiece === opponentPawn) {\n        enPassantVictimSquare.textContent = \"\";\n        } else {\n            // This case should ideally not happen if enPassantTarget is set correctly\n            enPassantVictimSquare = null; // Invalid en-passant if victim isn't there or isn't opponent pawn\n            originalEnPassantVictimPiece = null;\n        }\n    }\n  }\n\n  // --- Check if king is in check after simulated move ---\n  const kingNowInCheck = isKingInCheck(playerColor);\n\n  // --- Undo the simulation ---\n  fromSquareElement.textContent = movingPieceText;\n  toSquareElement.textContent = capturedPieceText;\n  kingData.kingRow = originalKingRow;\n  kingData.kingCol = originalKingCol;\n\n  if (isCastlingMove && castlingRookFromSquare && castlingRookToSquare) {\n    castlingRookFromSquare.textContent = castlingRookToSquare.textContent; // Rook back to original\n    castlingRookToSquare.textContent = originalRookTargetSquarePiece; // Restore empty or original content\n  }\n  if (enPassantVictimSquare && originalEnPassantVictimPiece) { // Only restore if it was removed\n    enPassantVictimSquare.textContent = originalEnPassantVictimPiece;\n  }\n  \n  return !kingNowInCheck;\n}\n\nfunction getAllLegalMovesForPlayer(playerColor) {\n  const legalMoves = [];\n  const playerPieceSet = playerColor === PLAYER.WHITE ? whitePieces : blackPieces;\n\n  if (!squares) return []; // Guard if squares is not initialized\n\n  for (let i = 0; i < squares.length; i++) {\n    const fromSquareElement = squares[i];\n    if (playerPieceSet.includes(fromSquareElement.textContent)) {\n      const pseudoLegalTargetSquares = getPseudoLegalMovesForPiece(fromSquareElement, playerColor);\n      for (const toSquareElement of pseudoLegalTargetSquares) {\n        if (isMoveLegal(fromSquareElement, toSquareElement, playerColor)) {\n          legalMoves.push({ from: fromSquareElement, to: toSquareElement });\n        }\n      }\n    }\n  }\n  return legalMoves;\n}\n\n// ===========================\n// Main Game Functions\n// ===========================\n\n/**\n * Entry point for the Chess application\n * Initializes the board and sets up event listeners\n */\nfunction initChessApp() {\n  console.log(\"initChessApp: Entered function.\"); // New Diagnostic A\n  // Create chessboard and set up pieces\n  console.log(\"initChessApp: About to call createChessboard and placePieces.\"); // New Diagnostic B\n  createChessboard();\n  placePieces();\n  squares = document.querySelectorAll('.square');\n\n  // Update the central state with the square DOM elements\n  // if (typeof window.updateState === 'function') {\n  //   window.updateState({ squares: Array.from(squares) }); // Use Array.from to store a plain array\n  //   console.log(\"SCRIPT_LOG: initChessApp - Updated central state with square DOM elements count:\", squares.length);\n  // } else {\n  //   console.error(\"SCRIPT_LOG: initChessApp - window.updateState is not available to update squares in central state.\");\n  // }\n  \n  // Set up promotion modal handlers\n  setupPromotionModal();\n  \n  // Set up undo button handler\n  const undoButton = document.getElementById('undo-button');\n  if (undoButton) {\n    undoButton.addEventListener('click', undoMove);\n  }\n  \n  // Check URL parameters for game mode\n  const urlParams = new URLSearchParams(window.location.search);\n  const modeParam = urlParams.get('mode');\n  \n  if (modeParam) {\n    switch(modeParam) {\n      case GAME_MODE.AI:\n        currentGameMode = GAME_MODE.AI;\n        // Auto-enable AI\n        const aiToggle = document.getElementById('ai-toggle');\n        if (aiToggle) {\n          aiToggle.checked = true;\n          if (typeof toggleAI === 'function') {\n            console.log(\"SCRIPT_LOG: initChessApp - Auto-enabling AI due to URL param.\");\n            toggleAI(true); // Call from ai.js\n          } else {\n            console.error(\"SCRIPT_LOG: initChessApp - toggleAI function not found!\");\n          }\n        }\n        break;\n      \n      case GAME_MODE.ONLINE:\n        currentGameMode = GAME_MODE.ONLINE;\n        // Initialize multiplayer\n        if (typeof initMultiplayer === 'function') {\n          initMultiplayer();\n        } else {\n          console.error('Multiplayer module not loaded');\n        }\n        break;\n      \n      default:\n        currentGameMode = GAME_MODE.LOCAL;\n    }\n  }\n  \n  // Update game status based on mode\n  updateGameStatus();\n  \n  // Set up back to home link\n  addBackToHomeLink();\n}\n\n/**\n * Add a back to home link to the page\n */\nfunction addBackToHomeLink() {\n  // Create a back link if it doesn't exist\n  if (!document.getElementById('back-to-home')) {\n    const backLink = document.createElement('a');\n    backLink.id = 'back-to-home';\n    backLink.href = 'home.html';\n    backLink.textContent = ' Back to Home';\n    backLink.className = 'back-link';\n    \n    // Insert it in a more structured way if possible, e.g., inside .container or at top of body\n    const container = document.querySelector('.container') || document.body;\n    container.prepend(backLink);\n  }\n}\n\n/**\n * Sets up the event listeners for the promotion modal choices.\n */\nfunction setupPromotionModal() {\n    console.log(\"setupPromotionModal: Entered function. promotionModal DOM element:\", promotionModal); // New Diagnostic C\n    if (!promotionModal) {\n        console.error(\"setupPromotionModal: promotionModal element not found! Cannot set up listeners.\");\n        return;\n    }\n    const promotionPiecesElements = promotionModal.querySelectorAll('.promotion-piece');\n    promotionPiecesElements.forEach(pieceElement => {\n        pieceElement.addEventListener('click', (e) => {\n            const pieceType = e.target.dataset.piece;\n            selectPromotionPiece(pieceType);\n        });\n    });\n}\n\n/**\n * Handles clicks on chessboard squares\n * @param {HTMLElement} square - The clicked square element\n */\nasync function squareClick(square) {\n  // Don't allow moves if the game is over\n  if (gameState.gameOver) return;\n  \n  // Online mode: only allow moves if it's the player's turn\n  if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive) {\n    if ((window.MP.playerColor === PLAYER.WHITE && window.turn !== PLAYER.WHITE) ||\n        (window.MP.playerColor === PLAYER.BLACK && window.turn !== PLAYER.BLACK)) {\n      console.log(\"Not your turn in online mode\");\n      return;\n    }\n  }\n  \n  // Start the clock if it's the first move and game is not online (online game start handled by multiplayer.js)\n  if (!CLOCK.isRunning && gameState.moveHistory.length === 0 && currentGameMode !== GAME_MODE.ONLINE && !gameState.gameOver) {\n    startClock();\n  }\n\n  // AI mode: enforce proper turn and piece constraints\n  if (currentGameMode === GAME_MODE.AI && window.aiActive && !window.isAIMakingMove) {\n    // Don't allow human player to move if it's AI's turn\n    if (window.turn === window.aiColor) {\n      console.log('Human click ignored: It is AI\\'s turn.');\n      return;\n    }\n    \n    // In AI mode, the human player should only be able to move their color pieces\n    // (opposite of AI color)\n    const humanColor = window.aiColor === PLAYER.WHITE ? PLAYER.BLACK : PLAYER.WHITE;\n    const pieceOnSquare = square.textContent;\n    const humanPieces = humanColor === PLAYER.WHITE ? whitePieces : blackPieces;\n    \n    // If a piece is selected and it's not the human's turn, clear the selection\n    if (selectedSquare && window.turn !== humanColor) {\n      cleanupAfterMove();\n      return;\n    }\n    \n    // If trying to select a piece and it's not the human's color, ignore\n    if (!selectedSquare && !humanPieces.includes(pieceOnSquare)) {\n      console.log('Cannot select opponent or AI pieces in AI mode');\n      return;\n    }\n  }\n\n  const pieceOnSquare = square.textContent;\n  const currentPlayerColor = window.turn;\n  const currentPlayerPieces = currentPlayerColor === PLAYER.WHITE ? whitePieces : blackPieces;\n  const opponentPieces = currentPlayerColor === PLAYER.WHITE ? blackPieces : whitePieces; // Not strictly needed here but good for clarity\n\n  if (selectedSquare) { // A piece is already selected\n    if (square === selectedSquare) { // Clicked selected square again\n      cleanupAfterMove(); // Deselect\n    } else if (currentPlayerPieces.includes(selectedSquare.textContent)) { // Own piece was selected\n      // Check if the target square is highlighted as a valid move (movelight or takelight)\n      if (square.classList.contains(\"movelight\") || square.classList.contains(\"takelight\")) {\n        // isMoveLegal check is implicitly handled by the highlighting logic in handlePieceSelect\n        // and re-verified within handlePieceMove simulation for safety.\n        if (currentPlayerColor === PLAYER.WHITE) {\n          await handleWhitePieceMove(square, parseInt(square.dataset.row), parseInt(square.dataset.col));\n        } else {\n          await handleBlackPieceMove(square, parseInt(square.dataset.row), parseInt(square.dataset.col));\n        }\n      } else { // Clicked an invalid target or another of own pieces\n        if (currentPlayerPieces.includes(pieceOnSquare)) { // Clicked another of own pieces\n            handlePieceSelect(square, currentPlayerColor); // Select the new piece\n        } else { // Invalid move to a non-highlighted square\n            highlightInvalidMove(square);\n            // cleanupAfterMove(); // Optionally deselect, or allow re-selection\n        }\n      }\n    }\n  } else { // No piece is selected yet\n    if (currentPlayerPieces.includes(pieceOnSquare)) { // Clicked on own piece\n      handlePieceSelect(square, currentPlayerColor);\n    } else {\n      // Clicked on empty square or opponent's piece when no piece selected - do nothing\n    }\n  }\n}\n\n/**\n * Modified function to handle moves for white pieces\n * Also tracks moves for multiplayer\n * @param {HTMLElement} square - The target square\n */\nasync function moveWhite(square) {\n  // Extract square coordinates\n  const sqRow = parseInt(square.dataset.row);\n  const sqCol = parseInt(square.dataset.col);\n  \n  // Get the index of the squares for multiplayer tracking (still useful for MP module)\n  const fromIndex = Array.from(squares).indexOf(selectedSquare);\n  const toIndex = Array.from(squares).indexOf(square);\n  \n  // The core move logic is now in handleWhitePieceMove -> handlePieceMove\n  await handleWhitePieceMove(square, sqRow, sqCol); \n  \n  // For online mode, send the move to the opponent\n  // This is for regular moves. Promotion moves are sent by selectPromotionPiece after local processing.\n  if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive && typeof window.sendMove === 'function') {\n    const lastMove = gameState.moveHistory[gameState.moveHistory.length -1];\n    if (lastMove && !lastMove.wasPromotion) { // Ensure it was not a promotion (which is handled by selectPromotionPiece)\n        // Send relevant part of the moveData. The MP module might only need from/to indices and promotion info.\n        const onlineMoveData = {\n            fromIndex: fromIndex,\n            toIndex: toIndex,\n            // Potentially add more from lastMove if needed by server, like piece, castling flags\n            // For now, keeping it minimal as per the original MP design for `sendMove`\n        };\n        console.log(\"Sending move to opponent (via moveWhite):\", onlineMoveData);\n        window.sendMove(onlineMoveData); \n    }\n  }\n}\n\n/**\n * Modified function to handle moves for black pieces\n * Also tracks moves for multiplayer\n * @param {HTMLElement} square - The target square\n */\nasync function moveBlack(square) {\n  // Extract square coordinates\n  const sqRow = parseInt(square.dataset.row);\n  const sqCol = parseInt(square.dataset.col);\n  \n  const fromIndex = Array.from(squares).indexOf(selectedSquare);\n  const toIndex = Array.from(squares).indexOf(square);\n  \n  await handleBlackPieceMove(square, sqRow, sqCol);\n    \n  if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive && typeof window.sendMove === 'function') {\n    const lastMove = gameState.moveHistory[gameState.moveHistory.length -1];\n    if (lastMove && !lastMove.wasPromotion) {\n        const onlineMoveData = {\n            fromIndex: fromIndex,\n            toIndex: toIndex,\n        };\n        console.log(\"Sending move to opponent (via moveBlack):\", onlineMoveData);\n        window.sendMove(onlineMoveData);\n    }\n  }\n}\n\n/**\n * Updates the game status display\n */\nfunction updateGameStatus() {\n  if (gameState.gameOver) {\n    // Show game over status (check, checkmate, etc.)\n    if (gameState.checkmate) {\n      const winner = window.turn === PLAYER.WHITE ? \"Black\" : \"White\";\n      gameStatus.textContent = `Checkmate! ${winner} wins!`;\n    } else if (gameState.stalemate) {\n      gameStatus.textContent = \"Stalemate! Game drawn.\";\n    } else if (gameState.fiftyMoveRule) {\n      gameStatus.textContent = \"Draw by fifty-move rule.\";\n    } else if (gameState.insufficientMaterial) {\n      gameStatus.textContent = \"Draw by insufficient material.\";\n    } else if (gameState.threefoldRepetition) {\n      gameStatus.textContent = \"Draw by threefold repetition.\";\n    }\n  } else {\n    // Show current player's turn and check status\n    const playerTurn = window.turn === PLAYER.WHITE ? \"White\" : \"Black\";\n    const oppColor = window.turn === PLAYER.WHITE ? \"black\" : \"white\";\n    \n    if (gameState.check) {\n      gameStatus.textContent = `${playerTurn} to move (in check)`;\n    } else {\n      // For online mode, show whose turn it is\n      if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive) {\n        if ((window.MP.playerColor === PLAYER.WHITE && window.turn === PLAYER.WHITE) ||\n            (window.MP.playerColor === PLAYER.BLACK && window.turn === PLAYER.BLACK)) {\n          gameStatus.textContent = \"Your turn to move\";\n        } else {\n          gameStatus.textContent = \"Opponent's turn to move\";\n        }\n      } else {\n        gameStatus.textContent = `${playerTurn} to move`;\n      }\n    }\n  }\n}\n\n/**\n * Custom function to handle pawn promotion\n * @param {HTMLElement} fromSquare - The square the pawn moved from\n * @param {HTMLElement} toSquare - The square the pawn moved to\n * @param {number} playerColor - The color of the player (PLAYER.WHITE or PLAYER.BLACK)\n */\nfunction handlePawnPromotion(fromSquare, toSquare, playerColor) {\n  // Store promotion data for multiplayer\n  pendingPromotion = {\n    fromSquare: fromSquare,\n    toSquare: toSquare,\n    playerColor: playerColor,\n    fromIndex: Array.from(squares).indexOf(fromSquare),\n    toIndex: Array.from(squares).indexOf(toSquare)\n  };\n  \n  // Show promotion selection UI\n  showPromotionModal(playerColor, parseInt(toSquare.dataset.row), parseInt(toSquare.dataset.col), pendingPromotion);\n}\n\n/**\n * Handle promotion piece selection with multiplayer support\n * @param {string} pieceType - The type of piece to promote to (queen, rook, bishop, knight)\n */\nfunction selectPromotionPiece(pieceType) {\n  if (!pendingPromotion || !pendingPromotion.moveData) {\n    console.error(\"Pending promotion or moveData is missing.\");\n    // Gracefully hide modal if something went wrong\n    promotionModal.style.display = 'none';\n    return;\n  }\n  \n  const { fromSquare, toSquare, playerColor, fromIndex, toIndex, moveData } = pendingPromotion;\n  const pieceSet = playerColor === PLAYER.WHITE ? pieces.white : pieces.black;\n  \n  let promotedPieceSymbol;\n  switch(pieceType) {\n    case 'queen': promotedPieceSymbol = pieceSet.queen; break;\n    case 'rook': promotedPieceSymbol = pieceSet.rook; break;\n    case 'bishop': promotedPieceSymbol = pieceSet.bishop; break;\n    case 'knight': promotedPieceSymbol = pieceSet.knight; break;\n    default: promotedPieceSymbol = pieceSet.queen; // Default to queen\n  }\n  \n  // Update the board with the chosen piece\n  toSquare.textContent = promotedPieceSymbol;\n  \n  // Finalize the moveData that was started in handlePieceMove\n  moveData.promotedToPieceType = pieceType;\n  // Ensure the pieceMovedOriginal in moveData is the pawn, if it was overwritten by a bug.\n  // (handlePieceMove should set pieceMovedOriginal correctly as the pawn initially).\n\n  // Push the now completed promotion move to history\n  gameState.moveHistory.push(moveData);\n\n  // For online mode, send the promotion choice\n  if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive && typeof window.sendMove === 'function') {\n    const onlinePromotionData = { \n      fromIndex: fromIndex, // from pendingPromotion\n      toIndex: toIndex,   // from pendingPromotion\n      promotion: pieceType \n    };\n    console.log(\"Sending promotion choice to opponent:\", onlinePromotionData);\n    window.sendMove(onlinePromotionData);\n  }\n  \n  // Clean up promotion state\n  pendingPromotion = null; // Clear pendingPromotion\n  promotionModal.style.display = 'none';\n  \n  // Continue with game flow that was paused for promotion\n  const newTurn = (playerColor === PLAYER.WHITE) ? PLAYER.BLACK : PLAYER.WHITE;\n  window.turn = newTurn; // For legacy use\n  CLOCK.activePlayer = newTurn; // Directly set clock's active player\n\n  if (typeof window.updateState === 'function') {\n    window.updateState({ turn: newTurn });\n    console.log(`SCRIPT_LOG: selectPromotionPiece - Called window.updateState({ turn: ${newTurn} })`);\n  } else {\n    console.warn(\"SCRIPT_LOG: selectPromotionPiece - window.updateState is not a function. AI might not get correct turn.\");\n  }\n  updateClockDisplay(); // Update clock display with the new active player\n  // switchClock(); // Original call replaced\n  \n  // Update game state after promotion and turn switch\n  const opponentColorNow = window.turn; // Current turn is now the opponent\n  if (isKingInCheck(opponentColorNow)) {\n      moveData.resultedInCheck = true; // Update the original moveData object\n      const opponentLegalMoves = getAllLegalMovesForPlayer(opponentColorNow);\n      if (opponentLegalMoves.length === 0) {\n          moveData.resultedInCheckmate = true; // Update the original moveData object\n      }\n  } else {\n      moveData.resultedInCheck = false;\n      moveData.resultedInCheckmate = false;\n  }\n\n  updateMoveHistory(); // Update history display with algebraic notation including promotion\n  checkForEndOfGame(); // This will call updateGameStatus and handle check/checkmate\n  cleanupAfterMove(); // Clear selection highlights, update danger lights etc.\n  \n  // AI Turn Check if applicable\n  console.log(`SCRIPT_LOG: selectPromotionPiece - After promotion. Current game mode: ${currentGameMode}, AI Active: ${window.aiActive}, Current turn: ${window.turn}, AI Color: ${window.aiColor}, Game Over: ${gameState.gameOver}`);\n  if (currentGameMode === GAME_MODE.AI && window.aiActive && window.turn === window.aiColor && !gameState.gameOver) {\n    if (typeof checkAITurn === 'function') {\n        console.log(\"SCRIPT_LOG: selectPromotionPiece - Conditions met for AI turn. Calling checkAITurn.\");\n        setTimeout(checkAITurn, 100); // Small delay for UI to catch up\n    } else {\n        console.error(\"SCRIPT_LOG: selectPromotionPiece - checkAITurn function not found!\");\n    }\n  } else {\n    console.log(\"SCRIPT_LOG: selectPromotionPiece - Conditions NOT met for AI turn after promotion.\");\n  }\n}\n\n\n// ===========================\n// Game Ending Logic\n// ===========================\n/**\n * Checks for checkmate or stalemate for the current player.\n * Updates game status and gameState.gameOver accordingly.\n */\nfunction checkForEndOfGame() {\n  const currentPlayer = window.turn;\n  // const opponentPlayer = (currentPlayer === PLAYER.WHITE) ? PLAYER.BLACK : PLAYER.WHITE; // Not directly needed here\n\n  // Update check status for current player\n  gameState.check = isKingInCheck(currentPlayer);\n\n  const legalMoves = getAllLegalMovesForPlayer(currentPlayer);\n\n  if (legalMoves.length === 0) {\n    gameState.gameOver = true;\n    if (gameState.check) { // Current player is in check and has no legal moves\n      gameState.checkmate = true;\n      // gameStatus.textContent will be updated by updateGameStatus()\n    } else { // No legal moves and not in check\n      gameState.stalemate = true;\n      // gameStatus.textContent will be updated by updateGameStatus()\n    }\n    stopClock(); // Stop clock on game end\n  } else {\n    gameState.gameOver = false;\n    gameState.checkmate = false;\n    gameState.stalemate = false;\n  }\n  // Other draw conditions (50-move, threefold repetition, insufficient material) would need more state tracking.\n  updateGameStatus(); // Always update status after checking for end of game\n}\n\n\n// ===========================\n// Detailed Piece Movement Handlers\n// ===========================\n\nfunction cleanupAfterMove() {\n  if (selectedSquare) {\n    selectedSquare.classList.remove(\"highlight\");\n  }\n  squares.forEach(s => {\n    s.classList.remove(\"movelight\");\n    s.classList.remove(\"takelight\");\n  });\n  \n  // Explicitly update dangerlight based on current check status for both kings\n  const whiteKingSquare = squares[pieces.white.kingRow * 8 + pieces.white.kingCol];\n  const blackKingSquare = squares[pieces.black.kingRow * 8 + pieces.black.kingCol];\n  \n  if (isKingInCheck(PLAYER.WHITE)) whiteKingSquare.classList.add(\"dangerlight\");\n  else whiteKingSquare.classList.remove(\"dangerlight\");\n  \n  if (isKingInCheck(PLAYER.BLACK)) blackKingSquare.classList.add(\"dangerlight\");\n  else blackKingSquare.classList.remove(\"dangerlight\");\n\n  selectedSquare = null;\n}\n\n/**\n * General handler for selecting a piece.\n * @param {HTMLElement} square - The clicked square with the piece.\n * @param {number} pieceColor - PLAYER.WHITE or PLAYER.BLACK.\n */\nfunction handlePieceSelect(square, pieceColor) {\n    cleanupAfterMove(); // Clear previous highlights before new selection\n    selectedSquare = square;\n    square.classList.add(\"highlight\");\n\n    const pseudoLegalMoves = getPseudoLegalMovesForPiece(square, pieceColor);\n    pseudoLegalMoves.forEach(targetSq => {\n        if (isMoveLegal(square, targetSq, pieceColor)) {\n            targetSq.classList.add(targetSq.textContent === \"\" ? \"movelight\" : \"takelight\");\n        }\n    });\n}\n\nasync function handlePieceMove(fromSquare, toSquare, pieceColor) {\n    const pieceText = fromSquare.textContent;\n    const capturedText = toSquare.textContent;\n    const fromRow = parseInt(fromSquare.dataset.row);\n    const fromCol = parseInt(fromSquare.dataset.col);\n    const toRow = parseInt(toSquare.dataset.row);\n    const toCol = parseInt(toSquare.dataset.col);\n\n    const moveData = {\n        from: { row: fromRow, col: fromCol },\n        to: { row: toRow, col: toCol },\n        pieceMovedOriginal: pieceText,\n        capturedPieceDirectly: null, \n        wasPromotion: false,\n        promotedToPieceType: null,\n        wasCastling: false,\n        castlingDetails: null,\n        wasEnPassantCapture: false,\n        enPassantVictimDetails: null,\n        previousEnPassantTarget: gameState.enPassantTarget, \n        prevWhiteCanCastleKingside: gameState.whiteCanCastleKingside,\n        prevWhiteCanCastleQueenside: gameState.whiteCanCastleQueenside,\n        prevBlackCanCastleKingside: gameState.blackCanCastleKingside,\n        prevBlackCanCastleQueenside: gameState.blackCanCastleQueenside,\n        playerColor: pieceColor, \n        resultedInCheck: false, \n        resultedInCheckmate: false \n    };\n\n    await animatePieceMovement(fromSquare, toSquare, pieceText);\n    toSquare.textContent = pieceText; \n    // fromSquare.textContent = \"\"; // Already cleared by animatePieceMovement or earlier if desired\n\n    if (capturedText !== \"\") {\n        moveData.capturedPieceDirectly = capturedText;\n        if (pieceColor === PLAYER.WHITE) gameState.capturedPieces.white.push(capturedText);\n        else gameState.capturedPieces.black.push(capturedText);\n    }\n    \n    if (pieceText === pieces.white.king) { pieces.white.kingRow = toRow; pieces.white.kingCol = toCol; }\n    if (pieceText === pieces.black.king) { pieces.black.kingRow = toRow; pieces.black.kingCol = toCol; }\n\n    if (pieceText === (pieceColor === PLAYER.WHITE ? pieces.white.king : pieces.black.king) && Math.abs(fromCol - toCol) === 2) {\n        moveData.wasCastling = true;\n        const kingInitialRow = pieceColor === PLAYER.WHITE ? 7 : 0;\n        const rookToMoveSymbol = pieceColor === PLAYER.WHITE ? pieces.white.rook : pieces.black.rook;\n        let rookFromSqElement, rookToSqElement;\n        if (toCol === 6) { // Kingside\n            rookFromSqElement = squares[kingInitialRow * 8 + 7];\n            rookToSqElement = squares[kingInitialRow * 8 + 5];\n            moveData.castlingDetails = { side: 'kingside', rookOriginalSquare: {row: kingInitialRow, col: 7}, rookNewSquare: {row: kingInitialRow, col: 5}};\n        } else { // Queenside (toCol === 2)\n            rookFromSqElement = squares[kingInitialRow * 8 + 0];\n            rookToSqElement = squares[kingInitialRow * 8 + 3];\n            moveData.castlingDetails = { side: 'queenside', rookOriginalSquare: {row: kingInitialRow, col: 0}, rookNewSquare: {row: kingInitialRow, col: 3}};\n        }\n        await animatePieceMovement(rookFromSqElement, rookToSqElement, rookToMoveSymbol); \n        rookToSqElement.textContent = rookToMoveSymbol;\n        // rookFromSqElement.textContent = \"\"; // Should be cleared by its animation\n    }\n\n    if (pieceText === pieces.white.king) {\n        gameState.whiteCanCastleKingside = false;\n        gameState.whiteCanCastleQueenside = false;\n    } else if (pieceText === pieces.black.king) {\n        gameState.blackCanCastleKingside = false;\n        gameState.blackCanCastleQueenside = false;\n    } else if (pieceText === pieces.white.rook) {\n        if (fromRow === 7 && fromCol === 0) gameState.whiteCanCastleQueenside = false;\n        if (fromRow === 7 && fromCol === 7) gameState.whiteCanCastleKingside = false;\n    } else if (pieceText === pieces.black.rook) {\n        if (fromRow === 0 && fromCol === 0) gameState.blackCanCastleQueenside = false;\n        if (fromRow === 0 && fromCol === 7) gameState.blackCanCastleKingside = false;\n    }\n    // If a rook is captured on its starting square, castling rights change.\n    if (capturedText === pieces.white.rook && toRow === 7 && toCol === 0) gameState.whiteCanCastleQueenside = false;\n    if (capturedText === pieces.white.rook && toRow === 7 && toCol === 7) gameState.whiteCanCastleKingside = false;\n    if (capturedText === pieces.black.rook && toRow === 0 && toCol === 0) gameState.blackCanCastleQueenside = false;\n    if (capturedText === pieces.black.rook && toRow === 0 && toCol === 7) gameState.blackCanCastleKingside = false;\n\n\n    const pawnBeingMoved = pieceColor === PLAYER.WHITE ? pieces.white.pawn : pieces.black.pawn;\n    if (pieceText === pawnBeingMoved && gameState.enPassantTarget &&\n        toRow === gameState.enPassantTarget.row && toCol === gameState.enPassantTarget.col &&\n        !capturedText) { \n        moveData.wasEnPassantCapture = true;\n        const victimPawnRow = pieceColor === PLAYER.WHITE ? toRow + 1 : toRow - 1;\n        const victimSquare = squares[victimPawnRow * 8 + toCol];\n        moveData.enPassantVictimDetails = { piece: victimSquare.textContent, row: victimPawnRow, col: toCol };\n        if (pieceColor === PLAYER.WHITE) gameState.capturedPieces.white.push(victimSquare.textContent);\n        else gameState.capturedPieces.black.push(victimSquare.textContent);\n        victimSquare.textContent = \"\"; \n    }\n\n    if (pieceText === pawnBeingMoved && Math.abs(fromRow - toRow) === 2) {\n        gameState.enPassantTarget = { row: (fromRow + toRow) / 2, col: toCol };\n  } else {\n        gameState.enPassantTarget = null;\n    }\n    \n    const promotionRow = pieceColor === PLAYER.WHITE ? 0 : 7;\n    if (pieceText === pawnBeingMoved && toRow === promotionRow) {\n        moveData.wasPromotion = true;\n        // Store the nearly complete moveData in pendingPromotion so selectPromotionPiece can finalize it.\n        pendingPromotion.moveData = moveData; \n        // `handlePawnPromotion` (called by `moveWhite`/`moveBlack` wrapper) will trigger `showPromotionModal`.\n        // The `showPromotionModal` itself doesn't need `moveData` passed directly if `pendingPromotion.moveData` is set.\n        // `selectPromotionPiece` will then use `pendingPromotion.moveData`.\n    }\n\n    if (!moveData.wasPromotion) { \n        const newTurn = (pieceColor === PLAYER.WHITE) ? PLAYER.BLACK : PLAYER.WHITE;\n        window.turn = newTurn; // For legacy use within script.js, if any\n        CLOCK.activePlayer = newTurn; // Directly set clock's active player\n\n        // Update turn state and check if AI should move\n        if (window.aiActive && engineReady && newTurn === window.aiColor && !gameState.gameOver) {\n            console.log(`Turn changed to ${newTurn === PLAYER.WHITE ? 'White' : 'Black'}, requesting AI move...`);\n            requestAIMove();\n        }\n        updateClockDisplay(); // Update clock display with the new active player\n        // switchClock(); // Original call replaced by direct CLOCK.activePlayer set and updateClockDisplay()\n\n        gameState.moveHistory.push(moveData); // Push non-promotion moves here\n    } else {\n        // For promotion moves, history push is deferred to `selectPromotionPiece`\n        // after the piece is chosen, so `promotedToPieceType` is known.\n    }\n    \n    const opponentPlayerColor = (pieceColor === PLAYER.WHITE) ? PLAYER.BLACK : PLAYER.WHITE;\n    if (isKingInCheck(opponentPlayerColor)) {\n        moveData.resultedInCheck = true;\n        const opponentLegalMoves = getAllLegalMovesForPlayer(opponentPlayerColor);\n        if (opponentLegalMoves.length === 0) {\n            moveData.resultedInCheckmate = true;\n        }\n    }\n\n    updateCapturedPieces();\n    updateMoveHistory(); \n    cleanupAfterMove(); \n    \n    // Send move to opponent if in multiplayer mode\n    console.log('Checking multiplayer conditions:', {\n        currentGameMode: currentGameMode,\n        GAME_MODE_ONLINE: GAME_MODE.ONLINE,\n        isMatchingMode: currentGameMode === GAME_MODE.ONLINE,\n        MP: window.MP ? 'exists' : 'undefined',\n        onlineActive: window.MP ? window.MP.onlineModeActive : 'N/A',\n        socketConnected: window.MP && window.MP.socket ? window.MP.socket.connected : 'N/A',\n        playerColor: window.MP ? window.MP.playerColor : 'N/A',\n        pieceColor: pieceColor,\n        sendMoveFunction: typeof window.sendMove === 'function' ? 'exists' : 'undefined'\n    });\n    \n    if (currentGameMode === GAME_MODE.ONLINE && window.MP && window.MP.onlineModeActive && window.MP.socket) {\n        console.log('Sending move to multiplayer system:', moveData);\n        // Make sure we're only sending our own moves, not reflecting opponent's moves\n        if ((window.MP.playerColor === PLAYER.WHITE && pieceColor === PLAYER.WHITE) ||\n            (window.MP.playerColor === PLAYER.BLACK && pieceColor === PLAYER.BLACK)) {\n            try {\n                if (typeof window.sendMove !== 'function') {\n                    console.error('sendMove function not available! Attempting to use fallback.');\n                    if (window.MP.socket && window.MP.socket.emit) {\n                        window.MP.socket.emit('make_move', {\n                            roomId: window.MP.roomId,\n                            move: `${moveData.pieceMovedOriginal},${moveData.from.row},${moveData.from.col},${moveData.to.row},${moveData.to.col}`\n                        });\n                        console.log('Used socket.emit fallback to send move');\n                    } else {\n                        console.error('No fallback available for sending moves!');\n                    }\n                } else {\n                    // Call the multiplayer module's sendMove function\n                    window.sendMove({\n                        piece: moveData.pieceMovedOriginal,\n                        from: moveData.from,\n                        to: moveData.to\n                    });\n                    console.log('Move sent to multiplayer server via window.sendMove');\n                }\n            } catch (error) {\n                console.error('Error sending move to multiplayer server:', error);\n            }\n        } else {\n            console.log('Not sending move - opponent\\'s move reflection');\n        }\n    }\n\n    if (!moveData.wasPromotion) {\n      checkForEndOfGame(); // This calls updateGameStatus internally\n      // AI Turn Check (if AI is active and it's now AI's turn)\n      console.log(`SCRIPT_LOG: handlePieceMove - After human move. Current game mode: ${currentGameMode}, AI Active: ${window.aiActive}, Current turn: ${window.turn}, AI Color: ${window.aiColor}, Game Over: ${gameState.gameOver}`);\n      if (currentGameMode === GAME_MODE.AI && window.aiActive && window.turn === window.aiColor && !gameState.gameOver) {\n        if (typeof checkAITurn === 'function') {\n            console.log(\"SCRIPT_LOG: handlePieceMove - Conditions met for AI turn. Calling checkAITurn.\");\n            setTimeout(checkAITurn, 100); // Small delay for AI to process UI updates\n        } else {\n            console.error(\"SCRIPT_LOG: handlePieceMove - checkAITurn function not found!\");\n        }\n      } else {\n        console.log(\"SCRIPT_LOG: handlePieceMove - Conditions NOT met for AI turn after human move.\");\n      }\n    } else {\n        console.log(\"SCRIPT_LOG: handlePieceMove - Move was a promotion. AI turn check deferred to selectPromotionPiece.\");\n        // For promotions, checkForEndOfGame will be called by selectPromotionPiece\n    }\n}\n\n\nasync function handleWhitePieceMove(square, sqRow, sqCol) {\n    await handlePieceMove(selectedSquare, square, PLAYER.WHITE);\n}\n\nasync function handleBlackPieceMove(square, sqRow, sqCol) {\n    await handlePieceMove(selectedSquare, square, PLAYER.BLACK);\n}\n\n\n// ===========================\n// Pawn Promotion Modal\n// ===========================\n/**\n * Shows the pawn promotion modal\n * Assumes pendingPromotion is already set by handlePawnPromotion, which should include\n * fromSquare, toSquare, playerColor, fromIndex, toIndex, and the partial moveData object.\n */\nfunction showPromotionModal(color, row, col) { \n  const whitePromos = document.querySelectorAll('.white-promotion');\n  const blackPromos = document.querySelectorAll('.black-promotion');\n  \n  if (color === PLAYER.WHITE) {\n    whitePromos.forEach(p => p.style.display = 'block');\n    blackPromos.forEach(p => p.style.display = 'none');\n  } else { // PLAYER.BLACK\n    whitePromos.forEach(p => p.style.display = 'none');\n    blackPromos.forEach(p => p.style.display = 'block');\n  }\n  promotionModal.style.display = 'flex';\n}\n\n\n// ===========================\n// Undo Move Functionality\n// ===========================\nfunction performUndoMove() {\n  if (gameState.moveHistory.length === 0) return;\n\n  const lastMove = gameState.moveHistory.pop();\n  const fromSq = squares[lastMove.from.row * 8 + lastMove.from.col];\n  const toSq = squares[lastMove.to.row * 8 + lastMove.to.col];\n\n  let pieceToRestore = lastMove.pieceMovedOriginal;\n    if (lastMove.wasPromotion) {\n      pieceToRestore = lastMove.playerColor === PLAYER.WHITE ? pieces.white.pawn : pieces.black.pawn;\n  }\n  fromSq.textContent = pieceToRestore;\n\n  if (lastMove.capturedPieceDirectly && !lastMove.wasEnPassantCapture) {\n      toSq.textContent = lastMove.capturedPieceDirectly;\n      if (lastMove.playerColor === PLAYER.WHITE) gameState.capturedPieces.white.pop();\n      else gameState.capturedPieces.black.pop();\n  } else if (!lastMove.wasCastling && !lastMove.wasEnPassantCapture) { \n      toSq.textContent = \"\";\n  }\n  \n  if (lastMove.pieceMovedOriginal === pieces.white.king) {\n      pieces.white.kingRow = lastMove.from.row; pieces.white.kingCol = lastMove.from.col;\n  } else if (lastMove.pieceMovedOriginal === pieces.black.king) {\n      pieces.black.kingRow = lastMove.from.row; pieces.black.kingCol = lastMove.from.col;\n  }\n\n  if (lastMove.wasEnPassantCapture) {\n      toSq.textContent = \"\"; \n      const victimDetails = lastMove.enPassantVictimDetails;\n      squares[victimDetails.row * 8 + victimDetails.col].textContent = victimDetails.piece;\n      if (lastMove.playerColor === PLAYER.WHITE) gameState.capturedPieces.white.pop();\n      else gameState.capturedPieces.black.pop();\n  }\n\n  if (lastMove.wasCastling) {\n      const kingInitialRow = lastMove.playerColor === PLAYER.WHITE ? 7 : 0;\n      const rookSymbol = lastMove.playerColor === PLAYER.WHITE ? pieces.white.rook : pieces.black.rook;\n      toSq.textContent = \"\"; \n\n      if (lastMove.castlingDetails.side === 'kingside') {\n          squares[kingInitialRow * 8 + 7].textContent = rookSymbol; \n          squares[kingInitialRow * 8 + 5].textContent = \"\";       \n      } else { // Queenside\n          squares[kingInitialRow * 8 + 0].textContent = rookSymbol; \n          squares[kingInitialRow * 8 + 3].textContent = \"\";       \n      }\n  }\n\n  gameState.enPassantTarget = lastMove.previousEnPassantTarget;\n  gameState.whiteCanCastleKingside = lastMove.prevWhiteCanCastleKingside;\n  gameState.whiteCanCastleQueenside = lastMove.prevWhiteCanCastleQueenside;\n  gameState.blackCanCastleKingside = lastMove.prevBlackCanCastleKingside;\n  gameState.blackCanCastleQueenside = lastMove.prevBlackCanCastleQueenside;\n  \n  window.turn = lastMove.playerColor; \n  CLOCK.activePlayer = window.turn; // Ensure clock active player is also reverted\n  \n  gameState.gameOver = false;\n  gameState.checkmate = false;\n  gameState.stalemate = false;\n  \n  updateCapturedPieces();\n  updateMoveHistory();\n  checkForEndOfGame(); \n  cleanupAfterMove(); \n  updateClockDisplay(); // Update clock display with new active player\n  \n  if (!CLOCK.isRunning && gameState.moveHistory.length > 0 && !gameState.gameOver) {\n      startClock();\n  }\n}\n\nfunction undoMove() {\n  if (gameState.moveHistory.length === 0) return;\n  if (currentGameMode === GAME_MODE.ONLINE) return; // No undo in online games for now\n\n  let movesToUndo = 1;\n  if (currentGameMode === GAME_MODE.AI && window.aiActive) {\n    const lastMoveData = gameState.moveHistory[gameState.moveHistory.length - 1];\n    // If AI just moved, and it was AI's turn, and there's a move before that (player's move)\n    if (lastMoveData.playerColor === window.aiColor && gameState.moveHistory.length > 1) {\n      movesToUndo = 2; // Undo AI's move and player's preceding move\n    }\n  }\n  \n  for (let i=0; i < movesToUndo; i++) {\n      if (gameState.moveHistory.length > 0) performUndoMove();\n  }\n\n  if (currentGameMode === GAME_MODE.AI && window.aiActive && window.turn === window.aiColor && !gameState.gameOver) {\n      if (typeof checkAITurn === 'function') {\n          setTimeout(checkAITurn, 100); // Delay for AI to process UI updates\n      }\n  }\n}\n\nconsole.log(\"Script: Reached point before adding DOMContentLoaded listener.\"); // New Diagnostic D\n// Initialize the app when the document is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log(\"Script: DOMContentLoaded event fired. About to call initChessApp.\"); // New Diagnostic E\n  initChessApp();\n});\n"],"names":["_regeneratorRuntime","r","t","e","Object","prototype","n","hasOwnProperty","o","Symbol","i","iterator","a","asyncIterator","u","toStringTag","c","defineProperty","value","enumerable","configurable","writable","h","Generator","create","Error","done","method","arg","delegate","d","f","sent","_sent","dispatchException","abrupt","s","type","Context","call","wrap","GeneratorFunction","GeneratorFunctionPrototype","l","p","getPrototypeOf","y","x","v","g","forEach","_invoke","AsyncIterator","_typeof","resolve","__await","then","TypeError","next","w","tryEntries","push","m","reset","isNaN","length","displayName","isGeneratorFunction","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","keys","unshift","pop","values","prev","charAt","slice","stop","rval","complete","finish","delegateYield","_createForOfIteratorHelper","Array","isArray","_unsupportedIterableToArray","_n","F","_slicedToArray","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","asyncGeneratorStep","_asyncToGenerator","arguments","apply","_next","_throw","_toConsumableArray","_arrayLikeToArray","_arrayWithoutHoles","from","_iterableToArray","_nonIterableSpread","toString","test","board","document","getElementById","console","log","gameStatus","moveList","whiteCaptured","blackCaptured","promotionModal","whiteTimeDisplay","blackTimeDisplay","whiteClockElement","querySelector","blackClockElement","PLAYER","GAME_MODE","currentGameMode","CLOCK","initialTime","whiteTime","blackTime","timerInterval","isRunning","activePlayer","lowTimeThreshold","selectedSquare","window","turn","pendingPromotion","squares","gameState","whiteCanCastleKingside","whiteCanCastleQueenside","blackCanCastleKingside","blackCanCastleQueenside","enPassantTarget","lastPawnDoubleMove","moveHistory","capturedPieces","white","black","moveCount","gameOver","check","checkmate","stalemate","fiftyMoveRule","insufficientMaterial","threefoldRepetition","castlingRightsSnapshot","pieces","king","queen","rook","bishop","knight","pawn","checked","checkSquare","kingRow","kingCol","whitePieces","blackPieces","formatTime","seconds","minutes","Math","floor","secs","concat","padStart","updateClockDisplay","textContent","classList","toggle","startClock","setInterval","handleTimeOut","stopClock","clearInterval","player","winner","checkForEndOfGame","updateCapturedPieces","innerHTML","piece","pieceElement","createElement","appendChild","updateMoveHistory","moveNumber","whiteMove","blackMove","moveItem","add","moveNumberElement","moveTextElement","moveText","algebraicNotation","scrollTop","scrollHeight","move","files","ranks","fromFile","col","toFile","row","to","toRank","pieceSymbol","pieceMovedOriginal","wasCastling","castlingDetails","side","captureSymbol","capturedPieceDirectly","wasEnPassantCapture","promotionSuffix","wasPromotion","promotedToPieceType","promotedPieceSymbol","checkSuffix","resultedInCheckmate","resultedInCheck","createPieceElement","pieceText","square","className","rect","getBoundingClientRect","style","position","left","top","width","height","display","alignItems","justifyContent","cs","getComputedStyle","fontSize","zIndex","pointerEvents","body","animatePieceMovement","_x","_x2","_x3","_animatePieceMovement","_callee","fromSquare","toSquare","_context","warn","pieceClone","toRect","currentRect","deltaX","deltaY","transition","requestAnimationFrame","transform","addEventListener","remove","once","highlightInvalidMove","setTimeout","isSquareUnderAttack","colorOfDefender","attackerColor","attackerPieceSet","pawnAttackDirection","_i","_knightMoves","_knightMoves$_i","newRow","newCol","_i2","_kingMoves","_kingMoves$_i","_i3","_straightDirections","_straightDirections$_","rowDir","colDir","pieceOnSquare","_i4","_diagonalDirections","_diagonalDirections$_","isKingInCheck","kingColor","kingData","undefined","error","getPseudoLegalMovesForPawn","sqRow","sqCol","pieceColor","moves","opponentPieces","direction","startRow","_i5","_arr","targetSquare","includes","getPseudoLegalMovesForRook","_i6","_directions","_directions$_i","getPseudoLegalMovesForKnight","ownPieces","_i7","_knightMoves2","_knightMoves2$_i","getPseudoLegalMovesForBishop","_i8","_diagonals","_diagonals$_i","getPseudoLegalMovesForQueen","getPseudoLegalMovesForKing","_i9","_kingMoves2","_kingMoves2$_i","kingInitialRow","canCastleKingside","canCastleQueenside","rookPiece","getPseudoLegalMovesForPiece","squareElement","parseInt","dataset","isMoveLegal","fromSquareElement","toSquareElement","playerColor","movingPieceText","capturedPieceText","fromCol","toRow","toCol","originalKingRow","originalKingCol","enPassantVictimSquare","originalEnPassantVictimPiece","isCastlingMove","castlingRookFromSquare","castlingRookToSquare","originalRookTargetSquarePiece","abs","kingNowInCheck","getAllLegalMovesForPlayer","legalMoves","playerPieceSet","_step","_iterator","err","initChessApp","initialSetup","DIsquareCount","_loop","squareClick","querySelectorAll","createChessboard","fill","sq","index","rowIndex","pieceType","colIndex","color","moveData","_pendingPromotion","fromIndex","toIndex","pieceSet","MP","onlineModeActive","sendMove","onlinePromotionData","promotion","newTurn","updateState","opponentColorNow","cleanupAfterMove","aiActive","aiColor","checkAITurn","selectPromotionPiece","target","setupPromotionModal","undoButton","undoMove","modeParam","URLSearchParams","location","search","get","aiToggle","toggleAI","initMultiplayer","updateGameStatus","backLink","id","href","prepend","addBackToHomeLink","_x4","_squareClick","_callee2","humanColor","_pieceOnSquare2","humanPieces","currentPlayerColor","currentPlayerPieces","_context2","isAIMakingMove","contains","handleWhitePieceMove","handleBlackPieceMove","handlePieceSelect","playerTurn","currentPlayer","whiteKingSquare","blackKingSquare","targetSq","handlePieceMove","_x7","_x8","_x9","_handlePieceMove","_callee5","capturedText","fromRow","rookToMoveSymbol","rookFromSqElement","rookToSqElement","pawnBeingMoved","victimPawnRow","victimSquare","promotionRow","opponentPlayerColor","_context5","enPassantVictimDetails","previousEnPassantTarget","prevWhiteCanCastleKingside","prevWhiteCanCastleQueenside","prevBlackCanCastleKingside","prevBlackCanCastleQueenside","rookOriginalSquare","rookNewSquare","engineReady","requestAIMove","GAME_MODE_ONLINE","isMatchingMode","onlineActive","socketConnected","socket","connected","sendMoveFunction","emit","roomId","_x0","_x1","_x10","_handleWhitePieceMove","_callee6","_context6","_x11","_x12","_x13","_handleBlackPieceMove","_callee7","_context7","performUndoMove","lastMove","fromSq","toSq","pieceToRestore","victimDetails","rookSymbol","movesToUndo"],"sourceRoot":""}