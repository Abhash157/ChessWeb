{"version":3,"file":"js/ai.04ec8a3e636246b02941.js","mappings":"AAUAA,OAAOC,UAAW,EAClBD,OAAOE,QAAUC,OAAOC,MACxBJ,OAAOK,gBAAiB","sources":["webpack://chessweb/./js/ai.js"],"sourcesContent":["/**\n * Chess AI Module\n * Integrates Stockfish chess engine for AI opponent\n */\n\nlet engine = null;\nlet engineReady = false;\nlet waitingForMove = false;\nlet aiDifficulty = 10; // Default: search depth 10\nlet aiThinking = false;\nwindow.aiActive = false; // Expose to global scope\nwindow.aiColor = PLAYER.BLACK; // AI plays as black by default, expose to global scope\nwindow.isAIMakingMove = false; // Flag for AI-driven moves\n\n/**\n * Initialize the Stockfish engine\n */\nasync function initEngine() {\n    try {\n        console.log('Initializing Stockfish engine as a Web Worker...');\n        \n        return new Promise((resolve, reject) => {\n            try {\n                // Create a web worker from the Stockfish script\n                engine = new Worker('./js/stockfish/stockfish-nnue-16-single.js');\n                \n                // Set up message handlers\n                engine.onmessage = function(event) {\n                    handleEngineMessage(event.data);\n                };\n                \n                engine.onerror = function(error) {\n                    console.error('Stockfish worker error:', error);\n                    reject(error);\n                };\n                \n                // Override the sendToEngine function for Web Worker usage\n                sendToEngine = function(command) {\n                    if (engine) {\n                        // console.log('To Engine:', command); // Reduced verbosity\n                        engine.postMessage(command);\n                    } else {\n                        console.error('Engine not initialized');\n                    }\n                };\n                \n                // Initialize engine with standard settings\n                sendToEngine('uci');\n                sendToEngine('isready');\n                \n                // Resolve after a small delay to ensure engine had time to initialize\n                setTimeout(() => {\n                    console.log('Stockfish engine initialized as Web Worker');\n                    engineReady = true;\n                    resolve(true);\n                }, 500);\n                \n            } catch (error) {\n                console.error('Failed to create Stockfish worker:', error);\n                reject(error);\n            }\n        });\n    } catch (error) {\n        console.error('Failed to initialize Stockfish:', error);\n        return false;\n    }\n}\n\n/**\n * Handle messages from the Stockfish engine\n * @param {string} message - Message from the engine\n */\nfunction handleEngineMessage(message) {\n    // console.log('Engine:', message); // Reduced verbosity, enable for deep debugging\n    \n    if (message === 'readyok') {\n        engineReady = true;\n        console.log('Stockfish engine ready');\n    }\n    \n    // Handle best move response\n    if (message.startsWith('bestmove')) {\n        console.log('Engine response:', message);\n        if (waitingForMove && aiThinking) {\n            const moveStr = message.split(' ')[1];\n            waitingForMove = false;\n            aiThinking = false;\n            console.log(`AI decided on move: ${moveStr}`);\n            makeAIMove(moveStr);\n        }\n    }\n}\n\n/**\n * Send a command to the Stockfish engine\n * @param {string} command - Command to send\n */\nfunction sendToEngine(command) {\n    if (engine) {\n        console.log('To Engine:', command);\n        engine.postMessage(command);\n    } else {\n        console.error('Engine not initialized');\n    }\n}\n\n/**\n * Convert current board position to FEN notation\n * @returns {string} FEN string representing current board position\n */\nfunction getCurrentFEN() {\n    let fen = '';\n    console.log(`getCurrentFEN: Accessing window.turn, value is: ${window.turn === PLAYER.WHITE ? 'White' : 'Black'} (raw: ${window.turn})`);\n    \n    // Board position (8 ranks)\n    for (let row = 0; row < 8; row++) {\n        let emptyCount = 0;\n        \n        for (let col = 0; col < 8; col++) {\n            const piece = squares[row * 8 + col].textContent;\n            \n            if (piece === '') {\n                emptyCount++;\n            } else {\n                // If there were empty squares before this piece, add the count\n                if (emptyCount > 0) {\n                    fen += emptyCount;\n                    emptyCount = 0;\n                }\n                \n                // Add the piece symbol (uppercase for white, lowercase for black)\n                const pieceSymbol = getFENSymbol(piece);\n                fen += pieceSymbol;\n            }\n        }\n        \n        // Add any remaining empty squares for this rank\n        if (emptyCount > 0) {\n            fen += emptyCount;\n        }\n        \n        // Add rank separator (except after the last rank)\n        if (row < 7) {\n            fen += '/';\n        }\n    }\n    \n    // Active color: w or b\n    const activeColorFEN = window.turn === PLAYER.WHITE ? ' w ' : ' b ';\n    fen += activeColorFEN;\n    console.log(`getCurrentFEN: Active color in FEN: '${activeColorFEN.trim()}'`);\n    \n    // Castling availability: KQkq or - if no castling is possible\n    let castling = '';\n    if (gameState.whiteCanCastleKingside) castling += 'K';\n    if (gameState.whiteCanCastleQueenside) castling += 'Q';\n    if (gameState.blackCanCastleKingside) castling += 'k';\n    if (gameState.blackCanCastleQueenside) castling += 'q';\n    fen += castling || '-';\n    \n    // En passant target square in algebraic notation\n    fen += ' ';\n    if (gameState.enPassantTarget) {\n        const file = 'abcdefgh'[gameState.enPassantTarget.col];\n        const rank = 8 - gameState.enPassantTarget.row;\n        fen += file + rank;\n    } else {\n        fen += '-';\n    }\n    \n    // Halfmove clock: number of halfmoves since the last capture or pawn advance\n    fen += ' 0 '; // We don't track this yet, so assume 0\n    \n    // Fullmove number: incremented after Black's move\n    const fullMoveCount = Math.floor((gameState.moveHistory.length + 1) / 2);\n    fen += fullMoveCount;\n    \n    console.log(`getCurrentFEN: Generated FEN: ${fen}`);\n    return fen;\n}\n\n/**\n * Convert a Unicode chess piece to FEN symbol\n * @param {string} piece - Unicode chess piece character\n * @returns {string} FEN symbol (P,N,B,R,Q,K for white; p,n,b,r,q,k for black)\n */\nfunction getFENSymbol(piece) {\n    // White pieces\n    if (piece === pieces.white.pawn) return 'P';\n    if (piece === pieces.white.knight) return 'N';\n    if (piece === pieces.white.bishop) return 'B';\n    if (piece === pieces.white.rook) return 'R';\n    if (piece === pieces.white.queen) return 'Q';\n    if (piece === pieces.white.king) return 'K';\n    \n    // Black pieces\n    if (piece === pieces.black.pawn) return 'p';\n    if (piece === pieces.black.knight) return 'n';\n    if (piece === pieces.black.bishop) return 'b';\n    if (piece === pieces.black.rook) return 'r';\n    if (piece === pieces.black.queen) return 'q';\n    if (piece === pieces.black.king) return 'k';\n    \n    return '';\n}\n\n/**\n * Request a move from the AI engine\n */\nfunction requestAIMove() {\n    console.log('requestAIMove called, engineReady:', engineReady, 'aiThinking:', aiThinking, 'gameOver:', gameState.gameOver, 'current window.turn:', window.turn === PLAYER.WHITE ? 'White' : 'Black', 'AI Color:', window.aiColor === PLAYER.WHITE ? 'White' : 'Black');\n    \n    if (!engineReady || !engine || aiThinking || gameState.gameOver) {\n        console.log('Skipping AI move request - not ready or already thinking or game over');\n        return;\n    }\n    \n    // Double check it's actually AI's turn\n    if (window.turn !== window.aiColor) {\n        console.log('Not AI\\'s turn in requestAIMove. Skipping AI move.');\n        return;\n    }\n    \n    console.log('Starting AI thinking process...');\n    console.log(`requestAIMove: Using aiDifficulty = ${aiDifficulty} for this move calculation.`);\n    \n    aiThinking = true;\n    waitingForMove = true;\n    \n    const fen = getCurrentFEN();\n    \n    sendToEngine('ucinewgame'); \n    sendToEngine(`position fen ${fen}`);\n\n    // Calculate and set Stockfish Skill Level based on aiDifficulty (slider 1-15)\n    // Skill Level (Stockfish 0-20)\n    const calculatedSkillLevel = Math.round(((aiDifficulty - 1) / 14) * 20);\n    console.log(`Mapping AI Difficulty (slider ${aiDifficulty}) to Stockfish Skill Level ${calculatedSkillLevel}`);\n    sendToEngine(`setoption name Skill Level value ${calculatedSkillLevel}`);\n    \n    // Set search parameters (depth or movetime) based on aiDifficulty\n    if (aiDifficulty <= 5) {\n        // Lower difficulty (slider 1-5) also implies lower depth. Skill Level will make it play weaker.\n        let engineDepth = aiDifficulty; // Depth 1 to 5\n        console.log(`Engine: go depth ${engineDepth} (Skill Level: ${calculatedSkillLevel})`);\n        sendToEngine(`go depth ${engineDepth}`);\n    } else {\n        // Higher difficulty (slider 6-15) uses movetime. Skill Level also scales up.\n        // Thinking time increases from 0.5s (for slider level 6) to 5s (for slider level 15).\n        const thinkTime = (aiDifficulty - 5) * 500; \n        console.log(`Engine: go movetime ${thinkTime}ms (Skill Level: ${calculatedSkillLevel})`);\n        sendToEngine(`go movetime ${thinkTime}`);\n    }\n}\n\n/**\n * Executes the move chosen by the AI\n * @param {string} uciMove - Move in UCI format (e.g., \"e2e4\")\n */\nasync function makeAIMove(uciMove) {\n    console.log(`Attempting to make AI move: ${uciMove}`);\n    if (!uciMove || uciMove.length < 4) {\n        console.error('Invalid AI move string:', uciMove);\n        aiThinking = false; // Reset thinking flag\n        return;\n    }\n\n    window.isAIMakingMove = true; // Set flag before simulating clicks\n    console.log('window.isAIMakingMove set to true');\n\n    // Parse the UCI move (e.g., \"e2e4\" to {fromCol: 4, fromRow: 6, toCol: 4, toRow: 4})\n    const fromCol = uciMove.charCodeAt(0) - 97; // 'a' is 97 in ASCII\n    const fromRow = 8 - parseInt(uciMove[1]); // Invert since our board is 0-indexed from top\n    const toCol = uciMove.charCodeAt(2) - 97;\n    const toRow = 8 - parseInt(uciMove[3]);\n\n    console.log(`Parsed AI move: from (${fromRow},${fromCol}) to (${toRow},${toCol})`);\n\n    // Get the squares\n    const fromSquare = squares[fromRow * 8 + fromCol];\n    const toSquare = squares[toRow * 8 + toCol];\n\n    if (!fromSquare || !toSquare) {\n        console.error('Could not find fromSquare or toSquare for AI move.');\n        aiThinking = false;\n        window.isAIMakingMove = false;\n        return;\n    }\n\n    console.log('Simulating click on fromSquare:', fromSquare);\n    await squareClick(fromSquare); // Use await if squareClick is async\n    \n    console.log('Simulating click on toSquare:', toSquare);\n    await squareClick(toSquare); // Use await if squareClick is async\n\n    // Handle promotion if applicable\n    if (uciMove.length > 4) {\n        const promotionPieceChar = uciMove[4];\n        console.log(`AI promotion detected. Piece: ${promotionPieceChar}`);\n        // Ensure promotion modal handling in script.js can be triggered programmatically if needed\n        // For now, assuming squareClick handles promotion selection if it's AI's turn\n        // This might require a more direct way to select the promotion piece if squareClick\n        // doesn't automatically open and allow selection for AI.\n        \n        // Find the correct promotion piece element and click it\n        // This part needs to be robust and might need adjustment based on how promotionModal works\n        const promotionPiecesElements = document.querySelectorAll('.promotion-piece');\n        let pieceType;\n        switch (promotionPieceChar) {\n            case 'q': pieceType = 'queen'; break;\n            case 'r': pieceType = 'rook'; break;\n            case 'b': pieceType = 'bishop'; break;\n            case 'n': pieceType = 'knight'; break;\n            default: pieceType = 'queen'; // Default to queen\n        }\n\n        console.log(`Looking for promotion piece type: ${pieceType} for color: ${PLAYER[window.aiColor]}`);\n        \n        // Determine the color of the promoting player (which is aiColor)\n        const promotingPlayerColorName = window.aiColor === PLAYER.WHITE ? 'white' : 'black';\n\n        for (const pieceElement of promotionPiecesElements) {\n            // Check if the piece is for the correct color and type\n            if (pieceElement.classList.contains(`${promotingPlayerColorName}-promotion`) && \n                pieceElement.getAttribute('data-piece') === pieceType) {\n                console.log('Found promotion piece element, simulating click:', pieceElement);\n                pieceElement.click(); // This should trigger the promotion finalization\n                break;\n            }\n        }\n    }\n    \n    // Ensure the turn has properly changed after AI move\n    const expectedPlayerTurn = window.aiColor === PLAYER.WHITE ? PLAYER.BLACK : PLAYER.WHITE;\n    if (window.turn === window.aiColor) {\n        console.warn('Turn did not change after AI move. Manually setting turn to player.');\n        window.turn = expectedPlayerTurn;\n        CLOCK.activePlayer = expectedPlayerTurn;\n        updateClockDisplay();\n        updateGameStatus();\n    }\n    \n    // Prevent AI from making another move immediately\n    waitingForMove = false;\n    \n    console.log('AI move simulation complete.');\n    aiThinking = false; // Reset thinking flag\n    window.isAIMakingMove = false; // Clear flag after move attempt\n    console.log('window.isAIMakingMove set to false');\n}\n\n/**\n * Set the AI difficulty level\n * @param {number} level - Difficulty level (1-15)\n */\nfunction setAIDifficulty(level) {\n    aiDifficulty = Math.max(1, Math.min(15, level));\n    console.log(`AI difficulty set to ${aiDifficulty}`);\n}\n\n/**\n * Toggle AI on/off\n * @param {boolean} active - Whether AI should be active\n */\nfunction toggleAI(active) {\n    // First, reset AI state variables to ensure clean state\n    aiThinking = false;\n    waitingForMove = false;\n    window.isAIMakingMove = false;\n    \n    // Now set the active state\n    window.aiActive = !!active; // Update global\n    console.log(`AI Toggled: ${window.aiActive}`);\n    \n    if (window.aiActive) {\n        if (!engineReady && !engine) {\n            console.log('Initializing engine for the first time...');\n            initEngine().then(ready => {\n                console.log('Engine initialization result:', ready);\n                if (ready) {\n                    console.log('Engine ready. Current turn:', window.turn === PLAYER.WHITE ? 'White' : 'Black', 'AI Color:', window.aiColor === PLAYER.WHITE ? 'White' : 'Black');\n                    // Only make a move if it's AI's turn and not already thinking\n                    if (window.turn === window.aiColor && !aiThinking && !waitingForMove) {\n                        console.log('AI active and it is AI\\'s turn, requesting move.');\n                        setTimeout(requestAIMove, 500); // Small delay to ensure UI is updated\n                    }\n                }\n            }).catch(error => {\n                console.error('Failed to initialize engine:', error);\n                alert('Failed to initialize the chess engine. Please try refreshing the page or check console for errors.');\n            });\n        } else if (engineReady) {\n            console.log('Engine already ready. Current turn:', window.turn === PLAYER.WHITE ? 'White' : 'Black', 'AI Color:', window.aiColor === PLAYER.WHITE ? 'White' : 'Black');\n            // Only make a move if it's AI's turn and not already thinking\n            if (window.turn === window.aiColor && !aiThinking && !waitingForMove) {\n                console.log('Engine ready and it is AI\\'s turn, requesting AI move...');\n                setTimeout(requestAIMove, 500); // Small delay to ensure UI is updated\n            }\n        }\n    } else if (engine) {\n        console.log('AI deactivated. Engine remains loaded.');\n        // Optionally, you could send 'stop' or 'quit' to the engine if desired\n    }\n}\n\n/**\n * Set the color that the AI plays as\n * @param {number} color - PLAYER.WHITE or PLAYER.BLACK\n */\nfunction setAIColor(color) {\n    window.aiColor = color; // Update global\n    console.log(`AI color set to: ${color === PLAYER.WHITE ? 'White' : 'Black'}`);\n    \n    // If it's already AI's turn, make a move\n    if (window.aiActive && engineReady && turn === window.aiColor && !gameState.gameOver) {\n        console.log('AI color changed, and it is now AI\\'s turn. Requesting move.');\n        requestAIMove();\n    }\n}\n\n/**\n * Check if it's AI's turn and request a move if needed\n * This should be called after a human makes a move\n */\nfunction checkAITurn() {\n    console.log(`checkAITurn called. AI Active: ${window.aiActive}, Engine Ready: ${engineReady}, Current Turn: ${window.turn === PLAYER.WHITE ? 'White' : 'Black'}, AI Color: ${window.aiColor === PLAYER.WHITE ? 'White' : 'Black'}, Game Over: ${gameState.gameOver}, AI Thinking: ${aiThinking}, Waiting for Move: ${waitingForMove}`);\n    \n    // Don't make a move if AI is already thinking or waiting for a move\n    if (aiThinking || waitingForMove) {\n        console.log('AI is already thinking or waiting for a move. Skipping checkAITurn.');\n        return;\n    }\n    \n    // Double check that it's actually AI's turn\n    if (window.turn !== window.aiColor) {\n        console.log('Not AI\\'s turn. Current turn:', window.turn === PLAYER.WHITE ? 'White' : 'Black');\n        return;\n    }\n    \n    if (window.aiActive && engineReady && window.turn === window.aiColor && !gameState.gameOver) {\n        console.log('It is AI\\'s turn. Requesting move with a delay...');\n        // Add a small delay to make the AI move feel more natural\n        setTimeout(requestAIMove, 300);\n    }\n}"],"names":["window","aiActive","aiColor","PLAYER","BLACK","isAIMakingMove"],"sourceRoot":""}